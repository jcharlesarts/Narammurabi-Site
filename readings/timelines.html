<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Timeline Trainer â€” BCE / CE</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Macondo+Swash+Caps&display=swap" rel="stylesheet">
<style>
  :root{
    --ink:#1b1b1b;
    --ink-soft:#3b3427;
    --bg:#f7f3e8; --bg2:#f1ead8; --card:#fffdf7; --soft:#e9e5da;
    --accent:#2f7d48; --accent-emerald:#2e7d32; --accent-teal:#0f766e; --warn:#9b1c1c;
    --gold:#d4af37; --gold-deep:#b48d1d; --muted:#6b5a40; --shadow:0 10px 26px rgba(0,0,0,.12);
  }
  html,body{margin:0;background:
      radial-gradient(1200px 560px at -10% -10%, #efe8d7 0, transparent 60%),
      radial-gradient(1200px 680px at 110% 0%, #efe3c7 0, transparent 55%),
      linear-gradient(var(--bg), var(--bg2)),
      repeating-linear-gradient(0deg, rgba(0,0,0,0.015) 0 2px, transparent 2px 6px);
    color:var(--ink-soft);font-family:'Cinzel', Georgia, 'Times New Roman', serif}
  .wrap{max-width:1280px;margin:20px auto;padding:16px}
  header{background:linear-gradient(180deg,#fffdf7,#fbf5e6);border:2px solid var(--gold);border-radius:16px;padding:14px 16px;box-shadow:0 12px 24px rgba(0,0,0,.10)}
  h1{margin:.2rem 0 .5rem;font-family:'Macondo Swash Caps', cursive}
  h2,h3{font-family:'Macondo Swash Caps', cursive}
  .muted{color:var(--muted)}
  .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
  .btn{border:1px solid var(--gold-deep);border-radius:12px;padding:10px 14px;min-height:44px;cursor:pointer;background:linear-gradient(180deg,#ffefc2,#f8de86);transition:transform .08s ease, box-shadow .08s ease}
  .btn:hover{transform:translateY(-1px);box-shadow:0 6px 14px rgba(0,0,0,.12)}
  .btn.primary{background:linear-gradient(180deg,#2f7d48,#1e5a34);color:#fff;border-color:#1e5a34}
  .btn.primary:hover{filter:saturate(1.08)}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  /* Bigger intro helper buttons */
  #coachToggle, #howToggle{ font-size:1.05rem; padding:12px 18px; min-height:52px }
  select, input[type="number"]{border:1px solid #c0b48a;border-radius:10px;padding:8px 10px;min-height:44px;background:#fff}
  .screen{background:var(--card);border:1px solid #e6d598;border-radius:14px;padding:14px 16px;box-shadow:var(--shadow);margin-top:16px}
  .flex{display:flex;gap:16px}
  @media (max-width: 980px){ .flex{flex-direction:column} }
  .main{flex:2 1 600px;min-width:0}
  .sidebar{flex:1 1 320px}
  .card{background:linear-gradient(180deg,#fffdf7,#fdf7e9);border:1px solid #eadfbf;border-radius:14px;padding:12px 14px;box-shadow:0 6px 18px rgba(0,0,0,.08)}
  .pill{display:inline-block;padding:4px 10px;border:1px solid var(--gold-deep);border-radius:999px;background:linear-gradient(180deg,#ffeaa1,#ffd664);margin:0 6px 6px 0;color:#3d301a}

  /* Activity areas */
  .stack,.order-area{display:flex;gap:10px;flex-wrap:wrap;min-height:80px}
  /* Order mode with fixed slots */
  .order-area.slots{flex-wrap:nowrap;justify-content:space-between;align-items:stretch}
  .slot{flex:1 1 120px;min-height:84px;border:2px dashed #c9c3ad;border-radius:12px;background:#fcfbf7;display:flex;align-items:center;justify-content:center;padding:6px;position:relative}
  .slot::before{content:attr(data-label);position:absolute;top:6px;left:8px;font-size:.8rem;color:#6b5a40}
  .slot.hover{border-color:var(--accent);background:#f3fff7}
  .slot.filled{border-style:solid;background:#fff}
  .slot .tile{margin:0;width:100%}
  .tile{user-select:none;background:linear-gradient(180deg,#ffffff,#fbf7ed);border:1px solid #e1d7b8;border-radius:12px;padding:10px;box-shadow:0 2px 10px rgba(0,0,0,.06);position:relative}
  .tile[draggable="true"]{cursor:grab}
  .tile.dragging{opacity:.6}
  .tile.selected{outline:2px solid var(--accent); box-shadow:0 0 0 3px rgba(47,125,72,.2)}
  .tile .year{font-weight:600;color:#2e3e47}
  .tile .label{font-size:.95rem}
  .dropzone{flex:1 1 120px;min-height:64px;border:2px dashed #c9c3ad;border-radius:12px;background:#fcfbf7;display:flex;align-items:center;justify-content:center;padding:6px}
  .dropzone.active{border-color:var(--accent);background:#f3fff7}
  .axis{position:relative;height:100px;border-radius:12px;background:
      linear-gradient(90deg, rgba(33,150,243,.06) 0 50%, rgba(255,87,34,.06) 50% 100%),
      linear-gradient(180deg,#fefefe,#f7f6f2);border:1px solid #e0d7ba;margin-top:8px}
  .zero{position:absolute;left:50%;top:0;bottom:0;width:3px;background:#cdbb90}
  .tick{position:absolute;bottom:0;width:1px;height:14px;background:#cdbb90}
  .tick small{position:absolute;bottom:16px;transform:translateX(-50%);color:#5a4a33}
  .meter{margin-top:8px}
  .bar{height:12px;background:linear-gradient(180deg,#efe9d7,#e6dcc0);border-radius:10px;overflow:hidden;border:1px solid #e1d7b8}
  .fill{height:100%;width:0;background:linear-gradient(90deg,#43a047,#2e7d32,#0f766e);transition:width .35s ease}
  .tiny{font-size:.9rem;color:#555}
  .feedback{margin-top:8px;font-weight:600}
  .correct{color:#2e7d32}
  .wrong{color:#c62828}
  .warning{color:var(--warn)}

  details{border:1px solid #eee;border-radius:10px;padding:10px 12px;background:#fff}
  summary{cursor:pointer;font-weight:600}
  .glossary b{font-weight:700}
  /* Vocabulary Coach (slide deck) */
  .coach{background:#fff;border:1px solid #eee;border-radius:12px;padding:12px 14px;box-shadow:var(--shadow)}
  .coach .title{font-weight:700;margin-bottom:6px}
  .tabbar{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px}
  .tabbar .tab{border:1px solid #c0b48a;border-radius:999px;padding:6px 10px;background:#fff;cursor:pointer;font-size:.95rem}
  .tabbar .tab.active{background:linear-gradient(180deg,#ffefc2,#f8de86);border-color:#b48d1d}
  .slides{position:relative;min-height:140px;border:1px solid #eee;border-radius:12px;background:#fcfbf7;padding:12px}
  .slidecard{font-size:1.05rem;line-height:1.45}
  .slidecard p{margin:.4rem 0}
  .pager{display:flex;align-items:center;gap:10px;margin-top:8px}
  .pager .btn{min-height:36px;padding:6px 12px}
  .dots{display:flex;gap:6px;margin-left:auto}
  .dot{width:10px;height:10px;border-radius:50%;background:#d6cfb6;border:1px solid #c0b48a}
  .dot.active{background:#2f7d48;border-color:#2f7d48}
  /* Guided timeline additions */
  .viewport{position:relative;height:140px;border-radius:12px;background:
      linear-gradient(90deg, rgba(33,150,243,.05) 0 50%, rgba(255,87,34,.05) 50% 100%),
      linear-gradient(180deg,#fefefe,#f7f6f2);border:1px solid #e0d7ba;margin-top:8px;overflow:hidden;touch-action:none}
  .g-zero{position:absolute;top:0;bottom:0;width:3px;background:#cdbb90}
  .g-tick{position:absolute;bottom:0;width:1px;height:14px;background:#cdbb90}
  .g-tick small{position:absolute;bottom:16px;transform:translateX(-50%);color:#5d5039}
  .marker{position:absolute;top:50%;width:0;height:0;transform:translate(-50%, -50%)}
  .marker .pin{position:absolute;left:50%;top:-18px;transform:translateX(-50%);width:8px;height:18px;background:var(--accent);border-radius:3px}
  .marker .head{position:absolute;left:50%;top:-26px;transform:translateX(-50%);width:16px;height:16px;background:var(--accent);border-radius:50%;box-shadow:0 2px 6px rgba(0,0,0,.2)}
  .marker.good .pin, .marker.good .head{background:#2e7d32}
  .marker.ok .pin, .marker.ok .head{background:#b9891a}
  .marker.off .pin, .marker.off .head{background:#c62828}
  .zoombar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:6px}
  .zoombar .btn{min-height:36px;padding:6px 10px}
  .guide-card .big{font-size:1.25rem;font-weight:600;font-family:'Macondo Swash Caps', cursive}
  .ghost{opacity:.3}
  /* Place mode snapping/locking */
  .tile.placed{transform:scale(.9); opacity:.98}
  .tile.snapped{animation:pop .18s ease-out}
  @keyframes pop{0%{transform:scale(.9)}60%{transform:scale(1.02)}100%{transform:scale(.9)}}
  .tick small{transition:transform .12s ease,color .12s ease}
  .tick.active small{color:#1e5a34;transform:translateY(-2px) scale(1.1);animation:pulse .6s ease-in-out infinite}
  @keyframes pulse{0%{transform:translateY(0) scale(1)}50%{transform:translateY(-3px) scale(1.08)}100%{transform:translateY(0) scale(1)}}
  .tick.micro{height:6px;opacity:.45}
  .axis:not(.vertical) .tick.active{height:22px;background:var(--accent)}
  .axis.vertical .tick.active{height:3px;background:#1e5a34}
  /* Pointer arrow for placed/dragging tiles */
  .axis:not(.vertical) .tile.placed::after, .axis:not(.vertical) .tile.dragging::after{
    content:"";position:absolute;left:50%;transform:translateX(-50%);bottom:-10px;width:0;height:0;
    border-left:8px solid transparent;border-right:8px solid transparent;border-top:10px solid var(--accent-emerald);
  }
  .axis.vertical .tile.placed::after, .axis.vertical .tile.dragging::after{
    content:"";position:absolute;top:50%;transform:translateY(-50%);left:-10px;width:0;height:0;
    border-top:8px solid transparent;border-bottom:8px solid transparent;border-right:10px solid var(--accent-emerald);
  }
  /* Unlock control */
  .unlock-btn{position:absolute;right:-8px;top:-8px;border:none;border-radius:50%;width:22px;height:22px;cursor:pointer;background:#fff;box-shadow:0 2px 6px rgba(0,0,0,.2);opacity:.0;transition:opacity .15s ease}
  .tile:hover .unlock-btn{opacity:1}
  .unlock-btn:after{content:"\1F513";font-size:14px;line-height:22px}
  /* Guided micro ticks */
  .g-tick.micro{height:6px;opacity:.45}
  .viewport:not(.vertical) .g-tick.active{height:22px;background:var(--accent)}
  .viewport.vertical .g-tick.active{height:3px;background:var(--accent)}
  /* Placed band below timeline */
  .placed-band{position:relative;min-height:140px;border:1px dashed #e0d7ba;border-radius:12px;background:linear-gradient(180deg,#fffdf7,#faf3df);margin-top:8px}
  .placed-band .tile{position:absolute;transform:scale(.9)}
  .placed-band .tile::after{content:"";position:absolute;left:50%;transform:translateX(-50%);top:-10px;width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:10px solid var(--accent)}
  /* Vertical orientation overrides */
  .axis.vertical{height:360px;background:
      linear-gradient(0deg, rgba(33,150,243,.06) 0 50%, rgba(255,87,34,.06) 50% 100%),
      linear-gradient(180deg,#fefefe,#f7f6f2)}
  .axis.vertical .zero{left:0;right:0;width:auto;height:3px;top:50%;bottom:auto}
  .axis.vertical .tick{bottom:auto;left:0;width:100%;height:1px}
  .axis.vertical .tick small{left:0;bottom:auto;top:-18px;transform:none}
  /* Wrong slot hint flash */
  .slot.wrong-glow{ border-color:#c62828 !important; animation:wrongGlow .9s ease-in-out 0s 2; }
  @keyframes wrongGlow{
    0%{ box-shadow:0 0 0 0 rgba(198,40,40,0); }
    50%{ box-shadow:0 0 0 6px rgba(198,40,40,.25); }
    100%{ box-shadow:0 0 0 0 rgba(198,40,40,0); }
  }
  .viewport.vertical{height:420px}
  .viewport.vertical .g-zero{left:0;right:0;width:auto;height:3px;top:50%;bottom:auto}
  .viewport.vertical .g-tick{bottom:auto;left:0;width:100%;height:1px}
  .viewport.vertical .g-tick small{left:0;bottom:auto;top:-18px;transform:none}
  /* Mode chooser */
  .mode-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:12px}
  .mode-card{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:160px;border:2px solid var(--gold-deep);border-radius:16px;background:linear-gradient(180deg,#ffeaa1,#ffd664);box-shadow:0 10px 22px rgba(0,0,0,.12);cursor:pointer;transition:transform .12s ease, box-shadow .12s ease}
  .mode-card:hover{transform:translateY(-2px);box-shadow:0 12px 22px rgba(0,0,0,.12)}
  .mode-card .title{font-family:'Macondo Swash Caps', cursive;font-size:1.4rem}
  .mode-card .desc{font-size:.9rem;color:#6b5a40;margin-top:6px;text-align:center;padding:0 8px}
  /* Coach panel */
  .coach-panel{max-height:0;overflow:hidden;transition:max-height .35s ease;margin-top:8px}
  .coach-panel.open{max-height:1000px}
  /* Move action buttons into screens */
  #check{ display:none !important; }
  .action-row{ display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; margin-top:10px }
  /* Solo view toggles via URL flags */
  body.solo #learnScreen { display:none !important; }
  body.noheader header { display:none !important; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Timeline Trainer â€” BCE / CE</h1>
    <p class="muted">Practice placing events in time. Learn the words that make timelines make sense.</p>
    <div id="controlsBar" class="controls" style="display:none">
      <label>Mode:
        <select id="mode">
          <option value="order">Order Mode (drag earliest â†’ latest)</option>
          <option value="place">Place Mode (drop on number line)</option>
          <option value="guided">Guided Timeline (zoom + labels)</option>
        </select>
      </label>
      <label>Orientation:
        <select id="orientation">
          <option value="horizontal" selected>Horizontal</option>
          <option value="vertical">Vertical</option>
        </select>
      </label>
      <label>Era Filter:
        <select id="era">
          <option value="mixed">BCE + CE</option>
          <option value="bce">BCE only</option>
          <option value="ce">CE only</option>
        </select>
      </label>
      <label># of Events:
        <select id="count">
          <option>5</option><option selected>7</option><option>10</option><option>12</option>
        </select>
      </label>
      <label>Timer:
        <select id="timer">
          <option value="0">No timer (practice)</option>
          <option value="60">60s</option>
          <option value="90" selected>90s</option>
          <option value="120">120s</option>
        </select>
      </label>
      <button id="start" class="btn primary">Start</button>
      <button id="check" class="btn" disabled>Check</button>
      <button id="reset" class="btn" disabled>Reset</button>
    </div>
  </header>

  <!-- Learn screen (pre-game) -->
  <section id="learnScreen" class="screen">
    <button id="coachToggle" class="btn">Want help understanding timelines?</button>
    <div id="coachPanel" class="coach-panel">
      <div class="coach" id="coach">
        <div class="title">Vocabulary Coach (Choose a word and click "next" to learn more!)</div>
        <div class="tabbar" id="coachTabs" role="tablist" aria-label="Vocabulary terms">
          <!-- tabs injected -->
        </div>
        <div class="slides" id="coachSlides" aria-live="polite">
          <!-- slide content injected -->
        </div>
        <div class="pager">
          <button id="coachPrev" class="btn" aria-label="Previous">â—€ Prev</button>
          <button id="coachNext" class="btn" aria-label="Next">Next â–¶</button>
          <div class="dots" id="coachDots" aria-hidden="true"></div>
        </div>
      </div>
    </div>
    <div class="mode-grid" aria-label="Choose a practice mode">
      <button id="quickOrder" class="mode-card" aria-label="Order Mode">
        <div class="title">Order</div>
        <div class="desc">Drag events into earliest â†’ latest sequence</div>
      </button>
      <button id="quickPlace" class="mode-card" aria-label="Place Mode">
        <div class="title">Place</div>
        <div class="desc">Drop events onto the number line</div>
      </button>
      <button id="quickGuided" class="mode-card" aria-label="Guided Timeline">
        <div class="title">Guided</div>
        <div class="desc">Pin the year; zoom and pan if needed</div>
      </button>
    </div>
    <button id="howToggle" class="btn" style="margin-top:8px">How it works</button>
    <div id="howPanel" class="coach-panel">
      <div class="card">
        <strong>How It Works</strong>
        <div class="tiny" style="margin-top:6px">
          <p><b>Order Mode</b></p>
          <ul>
            <li>Drag the event cards into the slots from <b>earliest</b> on the left to <b>latest</b> on the right.</li>
            <li>Fill every slot, then press <b>Finished!</b></li>
            <li>Wrong spots flash red. Fix them and try again.</li>
          </ul>
          <p><b>Place Mode</b></p>
          <ul>
            <li>Drag each card to the number line. Left is <b>BCE</b>, right is <b>CE</b>.</li>
            <li>Cards snap to nearby ticks. Use the unlock icon to move a placed card again.</li>
            <li>Press <b>Check</b> to see your average error in years.</li>
          </ul>
          <p><b>Guided Timeline</b></p>
          <ul>
            <li>Read the prompt, then click (or <b>Shift+click</b>) to place the year.</li>
            <li>Use <b>Zoom</b>, <b>Pan</b>, and <b>Center</b> to find the right spot.</li>
            <li>Press <b>Check</b> â†’ then <b>Next</b> or <b>Finish</b>.</li>
          </ul>
          <p><b>Timer & Score</b></p>
          <ul>
            <li>Choose a timer or practice with no timer.</li>
            <li>In Order Mode, finishing early adds a small time bonus.</li>
          </ul>
          <p><b>Tip</b>: The <b>Vocabulary Coach</b> above explains <b>BCE</b>, <b>CE</b>, centuries, and more.</p>
        </div>
      </div>
    </div>
    <div class="card" style="margin-top:10px">
      <strong>Teacher Tips</strong>
      <ul class="tiny">
        <li>Start with <i>Order</i> for simple sequencing; use <i>Place</i> or <i>Guided</i> to practice number lines.</li>
        <li>Horizontal or Vertical orientation supports different spatial preferences.</li>
        <li>Event cards always show the date with the title â€” students practice chronology, not recall.</li>
        <li>Edit the event library in the <code>EVENTS</code> array (bottom of this file).</li>
      </ul>
    </div>
    <details style="margin-top:10px">
      <summary>Why BCE / CE?</summary>
      <p class="tiny">We use <b>BCE</b> (Before Common Era) and <b>CE</b> (Common Era). These labels work for everyone in a global classroom. They match the same years as BC/AD but donâ€™t assume a religion or Latin words.</p>
    </details>
    <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap">
      <button id="enterGame" class="btn primary">Begin Game</button>
      <button id="openSolo" class="btn">Open Solo View</button>
    </div>
  </section>

  <section id="gameScreen" class="screen" hidden>
    <div class="flex">
      <div class="main" style="flex:1 1 auto">
        <div id="hud" class="card" style="display:flex;gap:14px;flex-wrap:wrap;align-items:center">
          <span class="pill" id="round">Round 0</span>
          <span class="pill" id="modeTag">â€”</span>
          <span class="pill" id="eraTag">â€”</span>
          <span class="pill" id="timerTag">â€”</span>
          <span class="pill" id="highTag">High: 0</span>
          <div class="meter" style="flex:1 1 200px">
            <div class="tiny">Score</div>
            <div class="bar"><div id="scoreFill" class="fill"></div></div>
            <div class="tiny"><span id="score">0</span> pts</div>
          </div>
          <button id="backIntro" class="btn">Back to First Screen</button>
        </div>

        <!-- ORDER MODE -->
        <div id="orderScreen" style="margin-top:10px" hidden>
          <h3>Drag the event cards so they go from <em>earliest</em> (left) to <em>latest</em> (right).</h3>
          <div id="orderBank" class="stack" aria-label="Card bank (drag from here)"></div>
          <div id="orderArea" class="order-area" aria-label="Timeline slots (drop here)"></div>
          <div id="orderFeedback" class="feedback"></div>
          <div class="action-row"><button id="orderFinish" class="btn primary">Finished!</button></div>
        </div>

        <!-- PLACE MODE -->
        <div id="placeScreen" style="margin-top:10px" hidden>
          <h3>Drag each event card onto the number line. Left is BCE, right is CE.</h3>
          <div id="stack" class="stack"></div>
          <div id="axis" class="axis" aria-label="timeline number line">
            <div class="zero" title="Year 0 (note: there is no year 0 in historical dating)"></div>
            <!-- ticks injected here -->
          </div>
          <div id="placedBand" class="placed-band"></div>
          <div id="placeFeedback" class="feedback"></div>
          <div class="action-row"><button id="placeCheckBtn" class="btn primary">Check</button></div>
        </div>

        <!-- GUIDED MODE -->
        <div id="guidedScreen" style="margin-top:10px" hidden>
          <h3>Place the event at the correct year on the timeline. Zoom or pan to find the right spot.</h3>
          <div id="guideCard" class="card guide-card" style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
            <div class="big" id="guidePrompt">Place: â€”</div>
          </div>
          <div class="zoombar">
            <button id="zoomOut" class="btn">âˆ’ Zoom out</button>
            <button id="zoomIn" class="btn">+ Zoom in</button>
            <button id="centerView" class="btn">Center</button>
            <span class="tiny" id="rangeTag">â€”</span>
            <span class="tiny" style="margin-left:auto">Tip: drag to pan â€¢ scroll to zoom â€¢ Shift+click to place</span>
          </div>
          <div id="gView" class="viewport" aria-label="interactive timeline">
            <div id="gZero" class="g-zero" title="Year 0"></div>
            <div id="gTicks"></div>
            <div id="gMarker" class="marker" hidden>
              <div class="head"></div>
              <div class="pin"></div>
            </div>
          </div>
          <div id="guideFeedback" class="feedback"></div>
          <div class="action-row"><button id="guidedActionBtn" class="btn primary">Check</button></div>
        </div>
      </div>
    </div>
  </section>
</div>

<script>
/* ===== Helpers ===== */
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const shuffle = a => { for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]} return a; };
const fmtYear = y => y < 0 ? `${Math.abs(y)} BCE` : `${y} CE`;

// Simple CSS.escape polyfill for older browsers
try{
  if (typeof window !== 'undefined' && (!window.CSS || typeof window.CSS.escape !== 'function')) {
    window.CSS = window.CSS || {};
    window.CSS.escape = function (s) { return String(s).replace(/[^a-zA-Z0-9_\-]/g, '\\$&'); };
  }
}catch(_e){}

/* ===== Vocabulary Coach (Tabbed Slide Deck) ===== */
const COACH_DATA = {
  "BCE": [
    "BCE means â€˜Before the Common Era.â€™",
    "We count backward in BCE. 300â€¯BCE is earlier than 200â€¯BCE.",
    "Think of numbers below zero on a thermometer: âˆ’300 is â€˜farther backâ€™ than âˆ’200."
  ],
  "CE": [
    "CE means â€˜Common Era.â€™",
    "CE starts at year 1 and goes up: 200â€¯CE comes after 100â€¯CE.",
    "CE matches the same years as AD, but uses neutral language."
  ],
  "Earlier vs Later": [
    "â€˜Earlierâ€™ means farther back in time. â€˜Laterâ€™ means closer to today.",
    "In CE: a smaller number is earlier (120â€¯CE is earlier than 300â€¯CE).",
    "In BCE: a bigger number is earlier (500â€¯BCE is earlier than 200â€¯BCE)."
  ],
  "Century": [
    "A century is 100 years.",
    "The 400sâ€¯CE are called the 5th centuryâ€¯CE (count the hundreds!).",
    "Tip: 1â€“100 = 1st century, 101â€“200 = 2nd, and so on."
  ],
  "Millennium": [
    "A millennium is 1,000 years.",
    "Examples: 1â€“1000â€¯CE (1st millennium); 1001â€“2000â€¯CE (2nd millennium).",
    "Millennia help us talk about very long timelines."
  ],
  "Year 0?": [
    "Historians donâ€™t use a year 0.",
    "Timelines sometimes show a middle line between BCE and CE.",
    "It goes â€¦ 2â€¯BCE, 1â€¯BCE, then 1â€¯CE, 2â€¯CE â€¦"
  ],
  "BCE/CE Story": [
    "Long ago, many books used BC (â€˜Before Christâ€™) and AD (Latin: â€˜Anno Dominiâ€™).",
    "In todayâ€™s world, classes include many cultures and religions.",
    "So we use BCE (â€˜Before the Common Eraâ€™) and CE (â€˜Common Eraâ€™).",
    "They point to the same exact years as BC/ADâ€”only the names changed.",
    "This keeps our timeline fair and easy for everyone to use.",
    "Youâ€™ll see BCE/CE in museums, libraries, and in this game!"
  ]
};
let coachTerm = Object.keys(COACH_DATA)[0];
let coachIndex = 0;
function renderCoach(){
  // Tabs
  const tabs = document.getElementById('coachTabs');
  tabs.innerHTML = '';
  Object.keys(COACH_DATA).forEach(term=>{
    const b = document.createElement('button');
    b.className = 'tab' + (term===coachTerm?' active':'');
    b.setAttribute('role','tab');
    b.setAttribute('aria-selected', term===coachTerm ? 'true':'false');
    b.textContent = term;
    b.addEventListener('click', ()=>{ coachTerm = term; coachIndex = 0; updateCoach(); });
    tabs.appendChild(b);
  });
  updateCoach();
}
function updateCoach(){
  const slides = COACH_DATA[coachTerm];
  if(!slides) return;
  // Content
  const area = document.getElementById('coachSlides');
  if(!area) return;
  area.innerHTML = '';
  const card = document.createElement('div');
  card.className = 'slidecard';
  // Split long slide into short lines for readability
  const text = slides[coachIndex];
  text.split(/\s*;\s*|\n/).forEach(line=>{
    const p = document.createElement('p');
    p.textContent = line;
    card.appendChild(p);
  });
  area.appendChild(card);
  // Tabs active state
  const tabs = Array.from(document.querySelectorAll('#coachTabs .tab'));
  tabs.forEach(t=>{
    const on = t.textContent===coachTerm; t.classList.toggle('active', on); t.setAttribute('aria-selected', on?'true':'false');
  });
  // Dots
  const dots = document.getElementById('coachDots');
  if(dots){
    dots.innerHTML = '';
    slides.forEach((_,i)=>{
      const d = document.createElement('div'); d.className = 'dot' + (i===coachIndex?' active':''); dots.appendChild(d);
    });
  }
  // Prev/Next enable
  const prevBtn = document.getElementById('coachPrev');
  const nextBtn = document.getElementById('coachNext');
  if(prevBtn) prevBtn.disabled = (coachIndex===0);
  if(nextBtn) nextBtn.disabled = (coachIndex===slides.length-1);
}
function nextCoach(){ const slides = COACH_DATA[coachTerm]; if(coachIndex < slides.length-1){ coachIndex++; updateCoach(); } }
function prevCoach(){ if(coachIndex>0){ coachIndex--; updateCoach(); } }

/* ===== Event Library (expand/modify freely) =====
 Each event: { title, year }  where BCE = negative year (221 BCE -> -221)
 Mix of world regions + eras; dates rounded where needed for classroom practice.
*/
const EVENTS = [
  // Deep Ancient (BCE)
  {title:"Earliest cuneiform writing in Sumer", year:-3200},
  {title:"Upper & Lower Egypt unified", year:-3100},
  {title:"Great Pyramid at Giza completed", year:-2560},
  {title:"Code of Hammurabi", year:-1754},
  {title:"Shang dynasty begins (China)", year:-1600},
  {title:"Iron use spreads (Anatolia)", year:-1200},
  {title:"Zhou dynasty begins (China)", year:-1046},
  {title:"First Olympic Games (Greece)", year:-776},
  {title:"Traditional founding of Rome", year:-753},
  {title:"Confucius born", year:-551},
  {title:"Siddhartha Gautama (Buddha) born (trad.)", year:-563},
  {title:"Roman Republic begins", year:-509},
  {title:"Battle of Marathon", year:-490},
  {title:"Battle of Thermopylae", year:-480},
  {title:"Peloponnesian War begins", year:-431},
  {title:"Socrates dies", year:-399},
  {title:"Alexander the Great becomes king", year:-336},
  {title:"Alexander the Great dies", year:-323},
  {title:"Qin unifies China", year:-221},
  {title:"Han dynasty begins (China)", year:-206},
  {title:"Rome defeats Carthage (3rd Punic War)", year:-146},
  {title:"Julius Caesar assassinated", year:-44},
  {title:"Augustus (Octavian) becomes first Roman emperor", year:-27},
  {title:"Wheel and plow used in Mesopotamia", year:-3500},
  {title:"Egyptian hieroglyphic writing appears", year:-3200},
  {title:"Bronze working spreads in the Near East", year:-3000},
  {title:"Cities of Mohenjo-Daro and Harappa thrive (Indus Valley)", year:-2600},
  {title:"Main circle of Stonehenge raised (Britain)", year:-2500},
  {title:"Mycenaean Greece rises", year:-1600},
  {title:"Hittite Empire grows in Anatolia", year:-1500},
  {title:"Olmec civilization begins (Mesoamerica)", year:-1500},
  {title:"Phoenician trading cities grow on the coast", year:-1400},
  {title:"Ramses II begins long reign in Egypt", year:-1279},
  {title:"Battle of Kadesh: Egypt vs. Hittites", year:-1274},
  {title:"Merneptah Stele mentions a people called â€˜Israelâ€™", year:-1208},
  {title:"Hittite Empire collapses", year:-1180},
  {title:"Alphabet spreads from the Phoenicians", year:-1100},
  {title:"Kingdom of Israel forms", year:-1000},
  {title:"Solomon builds a great temple in Jerusalem", year:-960},
  {title:"ChavÃ­n culture rises in the Andes (Peru)", year:-900},
  {title:"Carthage founded by Phoenician settlers (North Africa)", year:-814},
  {title:"Greek alphabet in use; oral epics take shape", year:-800},
  {title:"Assyria conquers the Kingdom of Israel (Samaria falls)", year:-722},
  {title:"Nok iron-working culture in West Africa", year:-700},
  {title:"First coins minted in Lydia (Asia Minor)", year:-600},
  {title:"Solonâ€™s reforms in Athens", year:-594},
  {title:"Babylonians destroy Jerusalem; many people exiled", year:-586},
  {title:"Cyrus the Great founds the Persian Empire", year:-550},
  {title:"Cyrus captures Babylon; people allowed to return home", year:-539},
  {title:"Cleisthenesâ€™ democratic reforms in Athens", year:-508},
  {title:"Greeks defeat Persians at Plataea", year:-479},
  {title:"Age of Pericles begins in Athens", year:-461},
  {title:"The Twelve Tables (early Roman laws) are posted", year:-450},
  {title:"Peloponnesian War ends; Sparta defeats Athens", year:-404},
  {title:"Plato founds the Academy in Athens", year:-387},
  {title:"Battle of Leuctra: Thebes defeats Sparta", year:-371},
  {title:"Philip II becomes king of Macedon", year:-359},
  {title:"Philip II wins at Chaeronea; Greece unites under Macedon", year:-338},
  {title:"Alexander invades the Persian Empire", year:-334},
  {title:"Battle of Gaugamela; Persia falls to Alexander", year:-331},
  {title:"Ptolemaic kingdom begins in Egypt", year:-305},
  {title:"Euclid writes Elements (geometry)", year:-300},
  {title:"Early Maya cities begin to grow (Mesoamerica)", year:-300},
  {title:"Qin crackdown on books and scholars (harsh rule)", year:-213},
  {title:"Shi Huangdi (Qin emperor) dies", year:-210},
  {title:"Hannibal defeated at the Battle of Zama", year:-202},
{title:"Yayoi rice farming spreads in Japan", year:-300},

  // Early CE
  {title:"Great Fire of Rome", year:64},
  {title:"Vesuvius erupts at Pompeii", year:79},
  {title:"Han dynasty ends (China)", year:220},
  {title:"Edict of Milan (toleration in Rome)", year:313},
  {title:"Fall of Western Roman Empire", year:476},
  {title:"Tang dynasty begins (China)", year:618},
  {title:"Battle of Tours", year:732},
  {title:"Charlemagne crowned emperor", year:800},
  {title:"Song dynasty begins (China)", year:960},
  {title:"Norman Conquest of England", year:1066},
  {title:"Genghis Khan unites the Mongols", year:1206},
  {title:"Magna Carta", year:1215},
  {title:"Mansa Musaâ€™s famous hajj", year:1324},
  {title:"Black Death reaches Europe", year:1347},
  {title:"Ottomans take Constantinople", year:1453},
  {title:"Gutenberg printing spreads (mid-1400s)", year:1455},
  {title:"Columbus reaches the Caribbean", year:1492},
  {title:"Martin Lutherâ€™s 95 Theses", year:1517},
  {title:"Mughal Empire founded (India)", year:1526},
  {title:"Tokugawa shogunate begins (Japan)", year:1603},
  {title:"Qing dynasty begins (China)", year:1644},
  {title:"American Declaration of Independence", year:1776},
  {title:"French Revolution begins", year:1789},
  {title:"Haitian Revolution begins", year:1791},
  {title:"Napoleon crowned emperor", year:1804},
  {title:"British Slavery Abolition Act", year:1833},
  {title:"First Opium War begins", year:1839},
  {title:"US Civil War begins", year:1861},
  {title:"Meiji Restoration (Japan)", year:1868},
  {title:"Berlin Conference (Africa partition)", year:1884},
  {title:"World War I begins", year:1914},
  {title:"Russian Revolution", year:1917},
  {title:"Treaty of Versailles", year:1919},
  {title:"Global Great Depression begins", year:1929},
  {title:"World War II begins", year:1939},
  {title:"World War II ends", year:1945},
  {title:"India becomes independent", year:1947},
  {title:"Peopleâ€™s Republic of China founded", year:1949},
  {title:"Korean War begins", year:1950},
  {title:"US Civil Rights Act", year:1964},
  {title:"First Moon landing", year:1969},
  {title:"Berlin Wall falls", year:1989},
  {title:"USSR dissolves", year:1991},
  {title:"End of apartheid elections (South Africa)", year:1994},
  {title:"September 11 attacks", year:2001},
  {title:"Global financial crisis", year:2008},
  {title:"Arab Spring peaks", year:2011},
  {title:"COVID-19 pandemic declared", year:2020},
];

/* ===== State ===== */
const TARGET_SCORE = 100;
let round = 0, score = 0, timerId = null, timeLeft = 0, initialRoundTime = 0;
let current = []; // events selected for round
let mode = 'order'; // 'order'|'place'

/* ===== DOM ===== */
const startBtn = $('#start'), resetBtn = $('#reset'), checkBtn = $('#check');
const modeSel = $('#mode'), eraSel = $('#era'), countSel = $('#count'), timerSel = $('#timer');
const orientationSel = $('#orientation');
const controlsBar = $('#controlsBar');
const learnScreen = $('#learnScreen');
const gameScreen = $('#gameScreen');
const enterGameBtn = $('#enterGame');
const openSoloBtn = $('#openSolo');
const scoreFill = $('#scoreFill'), scoreEl = $('#score'), roundEl = $('#round');
const modeTag = $('#modeTag'), eraTag = $('#eraTag'), timerTag = $('#timerTag');
const highTag = $('#highTag');
let highScore = 0; // session high score
const orderScreen = $('#orderScreen'), orderArea = $('#orderArea'), orderFeedback = $('#orderFeedback'), orderBank = $('#orderBank');
const placeScreen = $('#placeScreen'), axis = $('#axis'), placedBand = $('#placedBand'), placeFeedback = $('#placeFeedback'), stack = $('#stack');
// Guided DOM
const guidedScreen = document.getElementById('guidedScreen');
const guidePrompt = document.getElementById('guidePrompt');
const gView = document.getElementById('gView');
const gTicks = document.getElementById('gTicks');
const gZero = document.getElementById('gZero');
const gMarker = document.getElementById('gMarker');
const guideFeedback = document.getElementById('guideFeedback');
const zoomInBtn = document.getElementById('zoomIn');
const zoomOutBtn = document.getElementById('zoomOut');
const centerViewBtn = document.getElementById('centerView');
const rangeTag = document.getElementById('rangeTag');
// Local action buttons per screen
const orderFinishBtn = document.getElementById('orderFinish');
const placeCheckBtn = document.getElementById('placeCheckBtn');
const guidedActionBtn = document.getElementById('guidedActionBtn');
// Quick mode launchers on intro page
const quickOrderBtn = document.getElementById('quickOrder');
const quickPlaceBtn = document.getElementById('quickPlace');
const quickGuidedBtn = document.getElementById('quickGuided');
// Back to intro
const backIntroBtn = document.getElementById('backIntro');

/* ===== UI Helpers ===== */
function setHUD(){
  modeTag.textContent = (modeSel.value === 'order') ? 'Order Mode' : (modeSel.value === 'place' ? 'Place Mode' : 'Guided Timeline');
  eraTag.textContent = eraSel.value === 'mixed' ? 'BCE + CE' : (eraSel.value.toUpperCase());
  timerTag.textContent = +timerSel.value ? `${timerSel.value}s` : 'No timer';
  roundEl.textContent = `Round ${round}`;
  scoreEl.textContent = score.toString();
  scoreFill.style.width = Math.min(100, score).toString() + '%';
  if(highTag) highTag.textContent = `High: ${highScore}`;
  // Start button label: show Next if still playing toward target
  if(!startBtn.disabled){
    if(round>0 && score < TARGET_SCORE){ startBtn.textContent = 'Next'; }
    else { startBtn.textContent = 'Start'; }
  }
}
function startTimer(){
  const t = +timerSel.value;
  if(!t){ $('#timerTag').textContent = 'Practice'; return; }
  timeLeft = t;
  initialRoundTime = t;
  $('#timerTag').textContent = `${timeLeft}s`;
  clearInterval(timerId);
  timerId = setInterval(()=>{
    timeLeft -= 1;
    $('#timerTag').textContent = `${Math.max(0,timeLeft)}s`;
    if(timeLeft<=0){ clearInterval(timerId); timerId=null; checkRound(true); }
  }, 1000);
}

/* ===== Round building ===== */
function pickEvents(){
  const era = eraSel.value;
  let pool = EVENTS.slice();
  if(era==='bce') pool = pool.filter(e=>e.year<0);
  if(era==='ce')  pool = pool.filter(e=>e.year>0);
  shuffle(pool);
  const n = +countSel.value;
  current = pool.slice(0, n).map(e => ({...e, id: cryptoRandomId()}));
}
function cryptoRandomId(){
  // Simple unique id; ok if crypto unavailable
  try { return crypto.randomUUID(); } catch { return 'x'+Math.random().toString(36).slice(2,9); }
}

/* ===== ORDER MODE ===== */
function renderOrder(){
  orderFeedback.textContent = '';
  // build slots
  orderArea.innerHTML = '';
  orderArea.classList.add('slots');
  for(let i=0;i<current.length;i++){
    const slot = document.createElement('div');
    slot.className = 'slot';
    slot.dataset.index = i;
    slot.dataset.label = (i===0) ? '1 (earliest)' : (i===current.length-1 ? `${i+1} (latest)` : `${i+1}`);
    slot.setAttribute('aria-label', `Position ${i+1}`);
    orderArea.appendChild(slot);
  }
  // build shuffled bank
  if(orderBank){ orderBank.innerHTML = ''; }
  const pool = current.slice();
  shuffle(pool);
  pool.forEach(ev=>{
    const card = document.createElement('div');
    card.className = 'tile';
    card.draggable = true;
    card.dataset.id = ev.id;
    card.innerHTML = `<div class="label">${fmtYear(ev.year)} â€” ${ev.title}</div>`;
    orderBank.appendChild(card);
  });
  wireOrderDnD();
  wireOrderTap();
}

function wireOrderDnD(){
  // drag start/end for cards
  const onDragStart = (e)=>{
    const t = e.target.closest('.tile');
    if(!t) return; if(e.dataTransfer) e.dataTransfer.setData('text/plain', t.dataset.id||'');
    if(e.dataTransfer) e.dataTransfer.effectAllowed='move';
    t.classList.add('dragging');
  };
  const onDragEnd = (e)=>{ const el = e.target.closest('.tile'); if(el) el.classList.remove('dragging'); };
  [...document.querySelectorAll('#orderBank .tile, #orderArea .slot .tile')].forEach(t=>{
    t.addEventListener('dragstart', onDragStart);
    t.addEventListener('dragend', onDragEnd);
  });
  // allow dropping into bank
  if(orderBank){
    orderBank.addEventListener('dragover', e=>{ e.preventDefault(); e.dataTransfer && (e.dataTransfer.dropEffect='move'); });
    orderBank.addEventListener('drop', e=>{
      e.preventDefault();
      const id = e.dataTransfer ? e.dataTransfer.getData('text/plain') : '';
      if(!id) return;
      const card = document.querySelector(`.tile[data-id="${CSS.escape(id)}"]`);
      if(!card) return;
      // if it was in a slot, unfill that slot
      const parentSlot = card.closest('.slot');
      if(parentSlot){ parentSlot.classList.remove('filled'); }
      card.draggable = true;
      orderBank.appendChild(card);
    });
  }
  // each slot handles over/leave/drop
  $$('#orderArea .slot').forEach(slot=>{
    slot.addEventListener('dragover', e=>{ e.preventDefault(); e.dataTransfer && (e.dataTransfer.dropEffect='move'); slot.classList.add('hover'); });
    slot.addEventListener('dragleave', ()=> slot.classList.remove('hover'));
    slot.addEventListener('drop', e=>{
      e.preventDefault(); slot.classList.remove('hover');
      const id = e.dataTransfer ? e.dataTransfer.getData('text/plain') : '';
      if(!id) return;
      const card = document.querySelector(`.tile[data-id="${CSS.escape(id)}"]`);
      if(!card) return;
      // if slot already has a card, send it back to bank
      const existing = slot.querySelector('.tile');
      if(existing){ orderBank.appendChild(existing); }
      // if card came from another slot, unfill that one
      const fromSlot = card.closest('.slot');
      if(fromSlot && fromSlot!==slot){ fromSlot.classList.remove('filled'); }
      slot.appendChild(card);
      slot.classList.add('filled');
    });
  });
}
// Touch-friendly tap-to-place fallback for iPad
function wireOrderTap(){
  if(!orderArea || !orderBank) return;
  let selected = null;
  const select = (card)=>{
    if(selected) selected.classList.remove('selected');
    selected = card || null;
    if(selected) selected.classList.add('selected');
  };
  // Tap a card in bank to select
  orderBank.addEventListener('click', (e)=>{
    const card = e.target && e.target.closest ? e.target.closest('.tile') : null;
    if(card) select(card);
  });
  // Tap a card in a slot to select it (to move elsewhere)
  orderArea.addEventListener('click', (e)=>{
    const card = e.target && e.target.closest ? e.target.closest('.tile') : null;
    if(card){ select(card); return; }
    const slot = e.target && e.target.closest ? e.target.closest('.slot') : null;
    if(!slot) return;
    if(selected){
      const existing = slot.querySelector('.tile');
      if(existing){ orderBank.appendChild(existing); }
      const fromSlot = selected.closest('.slot');
      if(fromSlot){ fromSlot.classList.remove('filled'); }
      slot.appendChild(selected);
      slot.classList.add('filled');
      select(null);
    }
  });
}
function enableHorizontalDrag(container){
  let dragEl = null;
  container.addEventListener('dragstart', e=>{
    if(e.target.classList.contains('tile')){ dragEl = e.target; dragEl.classList.add('dragging'); if(e.dataTransfer) e.dataTransfer.effectAllowed='move'; }
  });
  container.addEventListener('dragend', ()=>{ if(dragEl){ dragEl.classList.remove('dragging'); dragEl=null; } });
  container.addEventListener('dragover', e=>{
    e.preventDefault();
    if(e.dataTransfer) e.dataTransfer.dropEffect='move';
    const after = getAfterElement(container, e.clientX);
    const dragging = container.querySelector('.dragging');
    if(!dragging) return;
    if(after==null){ container.appendChild(dragging); }
    else{ container.insertBefore(dragging, after); }
  });
  function getAfterElement(container, x){
    const els = [...container.querySelectorAll('.tile:not(.dragging)')];
    return els.reduce((closest, child)=>{
      const box = child.getBoundingClientRect();
      const offset = x - box.left - box.width/2;
      if(offset < 0 && offset > closest.offset) return {offset, element: child};
      else return closest;
    }, {offset: Number.NEGATIVE_INFINITY}).element;
  }
}
function gradeOrder(){
  const slots = $$('#orderArea .slot');
  // ensure all slots filled
  const unfilled = slots.some(s=>!s.querySelector('.tile'));
  if(unfilled){
    orderFeedback.innerHTML = `<span class="wrong">Fill all slots from earliest to latest before checking.</span>`;
    return false;
  }
  const ids = slots.map(s => s.querySelector('.tile').dataset.id);
  const correct = current.slice().sort((a,b)=>a.year-b.year).map(e=>e.id);
  let correctPositions = 0;
  const slotsEls = $$('#orderArea .slot');
  ids.forEach((id,i)=>{
    const isRight = id===correct[i];
    if(isRight) correctPositions++;
    else {
      const s = slotsEls[i];
      if(s){ s.classList.add('wrong-glow'); setTimeout(()=>s.classList.remove('wrong-glow'), 1200); }
    }
  });
  const n = current.length;
  const pct = Math.round((correctPositions/n)*100);
  const add = Math.round(pct/10);
  score += add;
  orderFeedback.innerHTML = (pct===100)
    ? `<span class="correct">Perfect order! +${add} pts</span>`
    : `<span class="warning">${correctPositions}/${n} in the right spot (${pct}%). +${add} pts</span><br><span class="tiny">Correct order:</span> ` +
      `<div class="tiny">${current.slice().sort((a,b)=>a.year-b.year).map(e=>fmtYear(e.year)+' â€” '+e.title).join('<br>')}</div>`;
  scoreFill.style.width = Math.min(100, score) + '%';
  return true;
}

/* ===== PLACE MODE ===== */
function renderAxis(){
  // Clear ticks
  $$('#axis .tick').forEach(t=>t.remove());
  // Make nice ticks based on selected events
  const years = current.map(e=>e.year);
  const min = Math.min(...years, -500);
  const max = Math.max(...years,  500);
  const span = max - min;
  const step = niceStep(span);
  const axis = $('#axis');
  const vertical = orientationSel.value === 'vertical';
  axis.classList.toggle('vertical', vertical);
  // expose axis scale for snapping
  window.__placeAxis = {min, max, step};
  for(let y = Math.ceil(min/step)*step; y <= max; y+=step){
    const tick = document.createElement('div');
    tick.className = 'tick';
    const pct = (y - min) / (max - min);
    if(vertical){ tick.style.top = (pct*100)+'%'; } else { tick.style.left = (pct*100)+'%'; }
    tick.innerHTML = `<small>${labelYear(y)}</small>`;
    tick.dataset.year = y;
    tick.dataset.pct = pct.toFixed(6);
    axis.appendChild(tick);
  }
  // micro ticks at decades
  const micro = 10;
  for(let y = Math.ceil(min/micro)*micro; y <= max; y += micro){
    const pct = (y - min) / (max - min);
    const t = document.createElement('div');
    t.className = 'tick micro';
    if(vertical){ t.style.top = (pct*100)+'%'; } else { t.style.left = (pct*100)+'%'; }
    t.dataset.year = y; t.dataset.pct = pct.toFixed(6);
    axis.appendChild(t);
  }
  // zero line pos
  const zeroPct = (0 - min) / (max - min);
  const zero = axis.querySelector('.zero');
  if(vertical){ zero.style.top = (zeroPct*100)+'%'; zero.style.left='0'; }
  else{ zero.style.left = (zeroPct*100)+'%'; zero.style.top='0'; }
}
function labelYear(y){ return y<0 ? `${Math.abs(y)} BCE` : `${y} CE`; }
function niceStep(span){
  const raw = span/8;
  const mags = [1,2,5,10,20,50,100,200,500,1000,2000,5000];
  return mags.find(m=>m>=raw) || 10000;
}
/* ===== PLACE PIN MODE (sequential) ===== */
let pIndex = 0; let pPlacedPct = null; let pIsGraded = false; let pYears = null; let pMin= -500, pMax=500;
const pMarker = document.getElementById('pMarker');
const placePromptEl = document.getElementById('placePrompt');
function initPinMode(){
  // compute range from current events with margin
  const years = current.map(e=>e.year);
  if(years.length){
    const min = Math.min(...years), max = Math.max(...years);
    const margin = Math.max(200, Math.round((max-min)*0.2));
    pMin = min - margin; pMax = max + margin;
  } else { pMin = -500; pMax = 500; }
  pYears = {min:pMin, max:pMax};
  // reset state
  pIndex = 0; pPlacedPct = null; pIsGraded = false; pMarker.hidden = true; placeFeedback.textContent='';
  // show first event
  showPinEvent();
  // interactions
  axis.onclick = (e)=>{
    const rect = axis.getBoundingClientRect();
    const vertical = orientationSel.value === 'vertical';
    const pct = Math.max(0, Math.min(1, vertical ? ((e.clientY - rect.top) / rect.height) : ((e.clientX - rect.left) / rect.width)));
    pPlacedPct = pct;
    placePinMarker(pPlacedPct);
  };
}
function showPinEvent(){
  const ev = current[pIndex];
  if(!ev){ // if we exhausted, repick
    pickEvents(); pIndex = 0;
  }
  const evt = current[pIndex];
  const oldBig = placePromptEl.querySelector('.big'); if(oldBig) oldBig.remove();
  const d = document.createElement('div'); d.className='big';
  d.textContent = `Pin: ${fmtYear(evt.year)} â€” ${evt.title}`;
  placePromptEl.appendChild(d);
  placeFeedback.textContent=''; pIsGraded=false; pPlacedPct=null; pMarker.hidden=true;
}
function placePinMarker(pct){
  const vertical = orientationSel.value === 'vertical';
  if(vertical){ pMarker.style.top = (pct*100)+'%'; pMarker.style.left='50%'; }
  else { pMarker.style.left = (pct*100)+'%'; pMarker.style.top='50%'; }
  pMarker.hidden = false;
}
function gradePin(){
  if(pPlacedPct==null){ placeFeedback.innerHTML = `<span class="wrong">Click the timeline to pin your answer.</span>`; return false; }
  const ev = current[pIndex];
  const yPlaced = pMin + pPlacedPct*(pMax - pMin);
  const err = Math.abs(yPlaced - ev.year);
  let add = 3, cls='off', note='off by ';
  if(err<=5){ add=10; cls='good'; note='perfect! '; }
  else if(err<=50){ add=8; cls='good'; note='very close â€” '; }
  else if(err<=200){ add=6; cls='ok'; note='close â€” '; }
  score += add;
  if(score > highScore){ highScore = score; }
  pMarker.classList.remove('good','ok','off'); pMarker.classList.add(cls);
  placeFeedback.innerHTML = `<span class="${add>=8?'correct':(add>=6?'warning':'wrong')}">${note}${Math.round(err)} years. +${add} pts</span>`;
  scoreFill.style.width = Math.min(100, score) + '%';
  setHUD();
  pIsGraded = true;
  checkBtn.textContent = 'Next';
  return true;
}
function nextPin(){
  pIndex++;
  if(pIndex >= current.length){ pickEvents(); pIndex = 0; }
  showPinEvent();
  checkBtn.textContent = 'Check';
}
function renderPlace(){
  stack.innerHTML='';
  placedBand.innerHTML='';
  placedBand.hidden = false;
  placeFeedback.textContent='';
  renderAxis();
  current.forEach(ev=>{
    const t = document.createElement('div');
    t.className = 'tile';
    t.draggable = true;
    t.dataset.id = ev.id;
    t.innerHTML = `<div class="label">${fmtYear(ev.year)} â€” ${ev.title}</div>`;
    stack.appendChild(t);
  });
  enablePlaceDrag();
  wirePlaceTap();
}
function enablePlaceDrag(){
  const axis = $('#axis');
  let dragging = null;
  let activeTick = null;
  $$('#stack .tile').forEach(t=>{
    t.addEventListener('dragstart', e=>{ dragging = t; t.classList.add('dragging'); if(e.dataTransfer) e.dataTransfer.effectAllowed='move'; });
    t.addEventListener('dragend', e=>{
      if(!dragging) return;
      dragging.classList.remove('dragging');
      dragging = null;
      if(activeTick){ activeTick.classList.remove('active'); activeTick = null; }
      axis.classList.remove('active-axis');
    });
  });
  // enable dragging from axis after unlock
  axis.addEventListener('dragstart', e=>{
    const t = e.target.closest && e.target.closest('.tile');
    if(!t) return; dragging = t; t.classList.add('dragging'); if(e.dataTransfer) e.dataTransfer.effectAllowed='move';
  });
  axis.addEventListener('dragend', e=>{
    const t = e.target.closest && e.target.closest('.tile');
    if(t){ t.classList.remove('dragging'); }
    dragging = null;
    if(activeTick){ activeTick.classList.remove('active'); activeTick = null; }
    axis.classList.remove('active-axis');
  });
  // enable dragging from placed band (after unlock)
  placedBand.addEventListener('dragstart', e=>{
    const t = e.target.closest && e.target.closest('.tile');
    if(!t) return; dragging = t; t.classList.add('dragging'); if(e.dataTransfer) e.dataTransfer.effectAllowed='move';
  });
  placedBand.addEventListener('dragend', e=>{
    const t = e.target.closest && e.target.closest('.tile');
    if(t){ t.classList.remove('dragging'); }
    dragging = null;
    if(activeTick){ activeTick.classList.remove('active'); activeTick = null; }
    axis.classList.remove('active-axis');
  });
  axis.addEventListener('dragover', e=>{
    e.preventDefault();
    if(e.dataTransfer) e.dataTransfer.dropEffect='move';
    axis.classList.add('active-axis');
    // highlight nearest tick
    const rect = axis.getBoundingClientRect();
    const vertical = orientationSel.value === 'vertical';
    const pct = vertical ? ((e.clientY - rect.top) / rect.height) : ((e.clientX - rect.left) / rect.width);
    const ticks = [...axis.querySelectorAll('.tick')];
    if(!ticks.length) return;
    let best = null, bestDiff = Infinity; 
    ticks.forEach(tk=>{
      const tp = parseFloat(tk.dataset.pct||'0');
      const diff = Math.abs(tp - pct);
      if(diff < bestDiff){ bestDiff = diff; best = tk; }
    });
    if(activeTick && activeTick!==best){ activeTick.classList.remove('active'); }
    activeTick = best; if(activeTick) activeTick.classList.add('active');
  });
  axis.addEventListener('drop', e=>{
    e.preventDefault();
    axis.classList.remove('active-axis');
    if(!dragging) return;
    // Position within axis
    const rect = axis.getBoundingClientRect();
    const vertical = orientationSel.value === 'vertical';
    let pct = vertical ? ((e.clientY - rect.top) / rect.height) : ((e.clientX - rect.left) / rect.width);
    // snap to nearest tick if any
    if(activeTick){ pct = parseFloat(activeTick.dataset.pct||pct); activeTick.classList.remove('active'); activeTick = null; }
    pct = Math.max(0, Math.min(1, pct));
    // Move to placed band and arrange
    placedBand.appendChild(dragging);
    dragging.dataset.pos = pct.toFixed(4);
    // lock + resize
    dragging.draggable = false;
    dragging.classList.add('placed','snapped');
    addUnlockButton(dragging);
    layoutPlacedBand();
  });
  axis.addEventListener('click', e=>{
    const btn = e.target.closest && e.target.closest('.unlock-btn');
    if(!btn) return;
    const tile = btn.closest('.tile');
    if(!tile) return;
    unlockTile(tile);
  });
  axis.addEventListener('dblclick', e=>{
    const tile = e.target.closest && e.target.closest('.tile');
    if(tile && tile.classList.contains('placed')) unlockTile(tile);
  });
  placedBand.addEventListener('click', e=>{
    const btn = e.target.closest && e.target.closest('.unlock-btn');
    if(!btn) return;
    const tile = btn.closest('.tile');
    if(!tile) return;
    unlockTile(tile);
  });
  placedBand.addEventListener('dblclick', e=>{
    const tile = e.target.closest && e.target.closest('.tile');
    if(tile && tile.classList.contains('placed')) unlockTile(tile);
  });
}
// Tap-friendly placement for iPad (select card -> tap line to place)
function wirePlaceTap(){
  if(!axis || !stack || !placedBand) return;
  let selected = null;
  const select = (tile)=>{
    if(selected) selected.classList.remove('selected');
    selected = tile || null;
    if(selected) selected.classList.add('selected');
  };
  // Tap a card in the stack to select
  stack.addEventListener('click', (e)=>{
    const tile = e.target && e.target.closest ? e.target.closest('.tile') : null;
    if(!tile) return;
    // If tile already placed, ignore here (handled by placedBand listener)
    if(tile.parentElement===placedBand) return;
    select(tile);
  });
  // Tap a placed tile to select for re-place
  placedBand.addEventListener('click', (e)=>{
    const btn = e.target && e.target.closest ? e.target.closest('.unlock-btn') : null;
    if(btn) return; // handled elsewhere
    const tile = e.target && e.target.closest ? e.target.closest('.tile') : null;
    if(!tile) return;
    select(tile);
  });
  // Tap the axis to place the selected tile
  axis.addEventListener('click', (e)=>{
    // ignore unlock clicks
    const onUnlock = e.target && e.target.closest ? e.target.closest('.unlock-btn') : null;
    if(onUnlock) return;
    if(!selected) return;
    const rect = axis.getBoundingClientRect();
    const vertical = orientationSel.value === 'vertical';
    let pct = vertical ? ((e.clientY - rect.top) / rect.height) : ((e.clientX - rect.left) / rect.width);
    // snap to nearest tick (including micro ticks)
    const ticks = [...axis.querySelectorAll('.tick')];
    if(ticks.length){
      let best = null, bestDiff = Infinity;
      const target = pct;
      ticks.forEach(tk=>{ const tp = parseFloat(tk.dataset.pct||'0'); const d = Math.abs(tp-target); if(d<bestDiff){ bestDiff=d; best=tk; } });
      if(best) pct = parseFloat(best.dataset.pct||pct);
    }
    pct = Math.max(0, Math.min(1, pct));
    // Move to placed band and arrange
    placedBand.appendChild(selected);
    selected.dataset.pos = pct.toFixed(4);
    selected.draggable = false;
    selected.classList.add('placed','snapped');
    addUnlockButton(selected);
    layoutPlacedBand();
    select(null);
  });
}
function addUnlockButton(tile){
  if(tile.querySelector('.unlock-btn')) return;
  const b = document.createElement('button');
  b.className = 'unlock-btn';
  b.title = 'Unlock to move';
  tile.appendChild(b);
}
function unlockTile(tile){
  tile.draggable = true;
  tile.classList.remove('placed');
  // keep current position until dropped again
  tile.style.left=''; tile.style.top='';
  if(typeof stack !== 'undefined' && stack){ stack.appendChild(tile); }
  layoutPlacedBand();
}
function layoutPlacedBand(){
  const band = placedBand;
  const tiles = [...band.querySelectorAll('.tile')];
  if(!tiles.length) return;
  const w = band.clientWidth || band.getBoundingClientRect().width;
  const margin = 14; const laneH = 56;
  // sort by pos
  tiles.sort((a,b)=>parseFloat(a.dataset.pos||'0')-parseFloat(b.dataset.pos||'0'));
  const lanes = [];
  tiles.forEach(tile=>{
    const pct = parseFloat(tile.dataset.pos||'0');
    // measure width
    tile.style.left='-1000px'; tile.style.top='0px';
    const width = tile.getBoundingClientRect().width || 240;
    const x = pct * w;
    const start = x - width/2 - margin;
    const end = x + width/2 + margin;
    let lane = 0, placed = false;
    while(!placed){
      if(!lanes[lane]) lanes[lane] = [];
      const overlaps = lanes[lane].some(seg => !(end < seg.start || start > seg.end));
      if(!overlaps){ lanes[lane].push({start,end}); placed = true; }
      else lane++;
    }
    tile.style.top = (lane*laneH)+'px';
    tile.style.left = `calc(${(pct*100).toFixed(2)}% - ${Math.round(width/2)}px)`;
  });
  // ensure band height accommodates lanes
  band.style.minHeight = Math.max(140, (lanes.length*laneH)+20)+'px';
}
function gradePlace(){
  // Map each tileâ€™s pos% to implied year on axis scale
  const years = current.map(e=>e.year);
  const min = Math.min(...years, -500);
  const max = Math.max(...years,  500);
  const span = max - min;
  // Build actual + placed arrays (from placed band)
  const placed = [];
  $$('#placedBand .tile').forEach(t=>{
    const id = t.dataset.id;
    const pct = parseFloat(t.dataset.pos||'NaN');
    placed.push({ id, pct });
  });
  // Check placed count
  if(placed.length < current.length){
    placeFeedback.innerHTML = `<span class="wrong">Place all cards on the line before checking.</span>`;
    return false;
  }
  // Compute absolute error in years
  let totalErr = 0;
  placed.forEach(p=>{
    const ev = current.find(e=>e.id===p.id);
    const yPlaced = min + (p.pct*span);
    totalErr += Math.abs(yPlaced - ev.year);
  });
  const avgErr = totalErr / current.length;
  // Points: better than 100 years avg => +10, 200 => +8, 300 => +6, else +3
  let add = 3;
  if(avgErr <= 100) add = 10;
  else if(avgErr <= 200) add = 8;
  else if(avgErr <= 300) add = 6;
  score += add;
  placeFeedback.innerHTML = `<span class="${add>=8?'correct':(add>=6?'warning':'wrong')}">Average error: ${Math.round(avgErr)} years. +${add} pts</span><br>
    <span class="tiny">Targets:</span><div class="tiny">${
      current.slice().sort((a,b)=>a.year-b.year).map(e=>fmtYear(e.year)+' â€” '+e.title).join('<br>')
    }</div>`;
  scoreFill.style.width = Math.min(100, score) + '%';
  return true;
}

/* ===== GUIDED MODE ===== */
let gIndex = 0; // which event within current
let gMin = -500, gMax = 500; // year range
let gIsGraded = false; // has current event been graded
let gPlacedYear = null; // current marker value
let isPanning = false, panStartX = 0, panStartY = 0, panStartMin = 0, panStartMax = 0;
let guidedWired = false;

function renderGuided(){
  guideFeedback.textContent='';
  // Range based on selected events + margin
  const years = current.map(e=>e.year);
  if(years.length===0){ return; }
  const min = Math.min(...years);
  const max = Math.max(...years);
  const margin = Math.max(200, Math.round((max-min)*0.2));
  setRange(min - margin, max + margin);
  gIndex = 0; gIsGraded = false; gPlacedYear = null; gMarker.hidden = true;
  showGuidedEvent();
  wireGuidedInteractions();
}
function setRange(min, max){
  // clamp to a broad world range
  const worldMin = -4000, worldMax = 2100;
  gMin = Math.max(worldMin, Math.min(min, worldMax-10));
  gMax = Math.min(worldMax, Math.max(max, worldMin+10));
  if(gMax - gMin < 20){ // prevent too narrow
    const mid = (gMin+gMax)/2; gMin = mid-10; gMax = mid+10;
  }
  updateGuidedAxis();
}
function updateGuidedAxis(){
  // ticks
  gTicks.innerHTML='';
  const span = gMax - gMin;
  const step = niceStep(span);
  const vertical = orientationSel.value === 'vertical';
  gView.classList.toggle('vertical', vertical);
  for(let y = Math.ceil(gMin/step)*step; y <= gMax; y+=step){
    const tick = document.createElement('div');
    tick.className = 'g-tick';
    const pct = (y - gMin) / (gMax - gMin);
    if(vertical){ tick.style.top = (pct*100)+'%'; } else { tick.style.left = (pct*100)+'%'; }
    tick.innerHTML = `<small>${labelYear(y)}</small>`;
    gTicks.appendChild(tick);
  }
  // micro ticks (decades)
  const micro = 10;
  for(let y = Math.ceil(gMin/micro)*micro; y <= gMax; y+=micro){
    const pct = (y - gMin) / (gMax - gMin);
    const t = document.createElement('div');
    t.className = 'g-tick micro';
    if(vertical){ t.style.top = (pct*100)+'%'; } else { t.style.left = (pct*100)+'%'; }
    gTicks.appendChild(t);
  }
  // zero line position
  const zeroPct = (0 - gMin) / (gMax - gMin);
  if(vertical){ gZero.style.top = (zeroPct*100)+'%'; gZero.style.left='0'; }
  else{ gZero.style.left = (zeroPct*100)+'%'; gZero.style.top='0'; }
  rangeTag.textContent = `${labelYear(Math.round(gMin))} â†’ ${labelYear(Math.round(gMax))}`;
  // update marker position if placed
  if(gPlacedYear!=null){ placeMarkerAtYear(gPlacedYear, false); }
}
function projectYearToPct(year){ return (year - gMin) / (gMax - gMin); }
function pctToYear(pct){ return gMin + pct * (gMax - gMin); }
function placeMarkerAtPct(pct){
  const clamped = Math.max(0, Math.min(1, pct));
  const vertical = orientationSel.value === 'vertical';
  if(vertical){ gMarker.style.top = (clamped*100)+'%'; gMarker.style.left='50%'; }
  else { gMarker.style.left = (clamped*100)+'%'; gMarker.style.top='50%'; }
  gMarker.hidden = false;
}
function placeMarkerAtYear(year, setState=true){
  const pct = projectYearToPct(year);
  placeMarkerAtPct(pct);
  if(setState){ gPlacedYear = year; }
}
function showGuidedEvent(){
  const ev = current[gIndex];
  guidePrompt.textContent = `Place: ${fmtYear(ev.year)} â€” ${ev.title}`;
  guideFeedback.textContent='';
  gIsGraded = false; gPlacedYear = null; gMarker.hidden = true;
  if(guidedActionBtn) guidedActionBtn.textContent = 'Check';
}
function checkGuided(){
  const ev = current[gIndex];
  if(gPlacedYear==null){ guideFeedback.innerHTML = `<span class="wrong">Click (or Shift+click) the timeline to place the year.</span>`; return false; }
  const err = Math.abs(gPlacedYear - ev.year);
  // distance score only
  let add = 3, cls='off', note='off by ';
  if(err<=5){ add=10; cls='good'; note='perfect! '; }
  else if(err<=50){ add=8; cls='good'; note='very close â€” '; }
  else if(err<=200){ add=6; cls='ok'; note='close â€” '; }
  score += add;
  // marker color
  gMarker.classList.remove('good','ok','off');
  gMarker.classList.add(cls);
  // feedback
  guideFeedback.innerHTML = `
    <span class="${add>=8?'correct':(add>=6?'warning':'wrong')}">${note}${Math.round(err)} years. +${add} pts</span>
    <div class="tiny">Target: ${fmtYear(ev.year)} â€” ${ev.title}</div>
  `;
  scoreFill.style.width = Math.min(100, score) + '%';
  setHUD();
  gIsGraded = true;
  if(guidedActionBtn) guidedActionBtn.textContent = (gIndex < current.length-1) ? 'Next' : 'Finish';
  return true;
}
function nextGuided(){
  if(gIndex < current.length-1){
    gIndex++; showGuidedEvent();
  }else{
    guideFeedback.innerHTML += `<div class="tiny">Round complete.</div>`;
    if(guidedActionBtn) guidedActionBtn.disabled = true;
    startBtn.disabled = false;
    if(timerId){ clearInterval(timerId); timerId = null; }
  }
}
function wireGuidedInteractions(){
  if(guidedWired) return; guidedWired = true;
  // wheel zoom
  gView.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect = gView.getBoundingClientRect();
    const vertical = orientationSel.value === 'vertical';
    const pct = vertical ? ((e.clientY - rect.top) / rect.height) : ((e.clientX - rect.left) / rect.width);
    const factor = e.deltaY < 0 ? 1.25 : 0.8;
    zoomAround(pct, factor);
  }, {passive:false});
  // pan
  gView.addEventListener('mousedown', (e)=>{
    if(e.shiftKey){
      const rect = gView.getBoundingClientRect();
      const vertical = orientationSel.value === 'vertical';
      const pct = vertical ? ((e.clientY - rect.top) / rect.height) : ((e.clientX - rect.left) / rect.width);
      const year = pctToYear(pct);
      placeMarkerAtYear(year);
      return;
    }
    isPanning = true; panStartX = e.clientX; panStartY = e.clientY; panStartMin = gMin; panStartMax = gMax;
    gView.classList.add('ghost');
  });
  window.addEventListener('mouseup', ()=>{ isPanning=false; gView.classList.remove('ghost'); });
  window.addEventListener('mousemove', (e)=>{
    if(!isPanning) return;
    const rect = gView.getBoundingClientRect();
    const vertical = orientationSel.value === 'vertical';
    const d = vertical ? (e.clientY - panStartY) : (e.clientX - panStartX);
    const dpct = vertical ? (d / rect.height) : (d / rect.width);
    const dYears = dpct * (panStartMax - panStartMin);
    setRange(panStartMin - dYears, panStartMax - dYears);
  });
  // click to place
  gView.addEventListener('click', (e)=>{
    const rect = gView.getBoundingClientRect();
    const vertical = orientationSel.value === 'vertical';
    const pct = vertical ? ((e.clientY - rect.top) / rect.height) : ((e.clientX - rect.left) / rect.width);
    const year = pctToYear(pct);
    placeMarkerAtYear(year);
  });
  // Touch gestures: two-finger pan and pinch-to-zoom
  const activePointers = new Map(); // id -> {x,y}
  let prevCenter = null; // in px along axis
  let prevDist = null;   // distance along axis in px
  const updatePointer = (e)=>{ activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY}); };
  const removePointer = (e)=>{ activePointers.delete(e.pointerId); if(activePointers.size < 2){ prevCenter = null; prevDist = null; } };
  gView.addEventListener('pointerdown', (e)=>{
    if(e.pointerType !== 'touch') return;
    e.preventDefault();
    gView.setPointerCapture && gView.setPointerCapture(e.pointerId);
    updatePointer(e);
    if(activePointers.size===2){
      const rect = gView.getBoundingClientRect();
      const pts = Array.from(activePointers.values());
      const vertical = orientationSel.value === 'vertical';
      const c = vertical ? ((pts[0].y + pts[1].y)/2 - rect.top) : ((pts[0].x + pts[1].x)/2 - rect.left);
      const d = Math.abs((vertical ? pts[0].y - pts[1].y : pts[0].x - pts[1].x));
      prevCenter = c; prevDist = d;
    }
  }, {passive:false});
  gView.addEventListener('pointermove', (e)=>{
    if(e.pointerType !== 'touch') return;
    if(!activePointers.has(e.pointerId)) return;
    e.preventDefault();
    updatePointer(e);
    if(activePointers.size>=2){
      const rect = gView.getBoundingClientRect();
      const pts = Array.from(activePointers.values());
      const vertical = orientationSel.value === 'vertical';
      const centerNow = vertical ? ((pts[0].y + pts[1].y)/2 - rect.top) : ((pts[0].x + pts[1].x)/2 - rect.left);
      const distNow = Math.abs((vertical ? pts[0].y - pts[1].y : pts[0].x - pts[1].x));
      if(prevCenter==null || prevDist==null){ prevCenter = centerNow; prevDist = distNow; return; }
      // Pan: move by center delta
      const axisLen = vertical ? rect.height : rect.width;
      const dCenter = centerNow - prevCenter;
      if(axisLen>0 && Math.abs(dCenter) > 0){
        const dpct = dCenter / axisLen;
        const dYears = dpct * (gMax - gMin);
        setRange(gMin - dYears, gMax - dYears);
      }
      // Pinch: zoom by distance ratio
      if(prevDist>0 && distNow>0){
        const factor = distNow/prevDist;
        if(Math.abs(factor-1) > 0.01){
          const pct = centerNow / (axisLen||1);
          zoomAround(pct, factor);
        }
      }
      prevCenter = centerNow; prevDist = distNow;
    }
  }, {passive:false});
  const endEvents = ['pointerup','pointercancel','pointerleave','pointerout'];
  endEvents.forEach(type=>{
    gView.addEventListener(type, (e)=>{ if(e.pointerType==='touch'){ removePointer(e); } }, {passive:true});
  });
  // buttons
  zoomInBtn.addEventListener('click', ()=> zoomAround(0.5, 1.25));
  zoomOutBtn.addEventListener('click', ()=> zoomAround(0.5, 0.8));
  centerViewBtn.addEventListener('click', ()=>{
    const years = current.map(e=>e.year);
    const min = Math.min(...years);
    const max = Math.max(...years);
    const margin = Math.max(200, Math.round((max-min)*0.2));
    setRange(min - margin, max + margin);
  });
}
function zoomAround(pct, factor){
  const center = pctToYear(pct);
  const span = (gMax - gMin) / factor;
  const newMin = center - pct * span;
  const newMax = newMin + span;
  setRange(newMin, newMax);
}

/* ===== Round flow ===== */
function startRound(){
  round++; setHUD();
  pickEvents();
  mode = modeSel.value;
  $('#check').disabled = false;
  $('#reset').disabled = false;
  $('#start').disabled = true;
  orderScreen.hidden = mode!=='order';
  placeScreen.hidden = mode!=='place';
  guidedScreen.hidden = mode!=='guided';
  // Label local action buttons for the current mode
  if(orderFinishBtn) orderFinishBtn.textContent = 'Finished!';
  if(placeCheckBtn) placeCheckBtn.textContent = 'Check';
  if(guidedActionBtn) guidedActionBtn.textContent = 'Check';
  if(orderFinishBtn) orderFinishBtn.disabled = (mode!=='order');
  if(placeCheckBtn) placeCheckBtn.disabled = (mode!=='place');
  if(guidedActionBtn) guidedActionBtn.disabled = (mode!=='guided');
  if(mode==='order') renderOrder();
  else if(mode==='place') renderPlace();
  else renderGuided();
  startTimer();
}
function checkRound(auto=false){
  if(mode==='place'){
    const ok = gradePlace();
    if(ok){
      clearInterval(timerId); timerId=null;
      $('#start').disabled = false;
      if(placeCheckBtn) placeCheckBtn.disabled = true;
    }else if(auto){
      placeFeedback.innerHTML += `<div class="tiny">Time! Round ended.</div>`;
      $('#start').disabled = false;
      if(placeCheckBtn) placeCheckBtn.disabled = true;
    }
    setHUD();
    return;
  }
  if(mode==='guided'){
    if(!gIsGraded){
      const graded = checkGuided();
      if(!graded && auto){ guideFeedback.innerHTML += `<div class=\"tiny\">Time! Round ended.</div>`; if(guidedActionBtn) guidedActionBtn.disabled = true; startBtn.disabled=false; }
    }else{
      nextGuided();
    }
    setHUD();
    return;
  }
  const ok = (mode==='order') ? (gradeOrder(), true) : gradePlace();
  if(ok){
    // Time bonus only for Order Mode with a timer selected
    if(mode==='order' && initialRoundTime>0 && typeof timeLeft==='number'){
      const baseline = 90; // default option in UI
      const difficulty = Math.max(0.5, Math.min(2, baseline / initialRoundTime)); // shorter timer = higher multiplier
      const secs = Math.max(0, timeLeft);
      const tBonus = Math.round(secs * 0.1 * difficulty); // ~1 pt per 10s at baseline; scales with difficulty
      if(tBonus>0){
        score += tBonus;
        scoreFill.style.width = Math.min(100, score) + '%';
        orderFeedback.innerHTML += `<div class=\"tiny\">Time bonus: +${tBonus} pts (${secs}s left; Ã—${difficulty.toFixed(2)})</div>`;
      }
    }
    clearInterval(timerId); timerId=null;
    $('#start').disabled = false;
    if(mode==='order' && orderFinishBtn) orderFinishBtn.disabled = true;
    if(mode==='place' && placeCheckBtn) placeCheckBtn.disabled = true;
    if(mode==='guided' && guidedActionBtn) guidedActionBtn.disabled = true;
  }else if(auto){
    // Time ran out but not all placed
    placeFeedback.innerHTML += `<div class=\"tiny\">Time! Round ended.</div>`;
    $('#start').disabled = false;
    if(mode==='order' && orderFinishBtn) orderFinishBtn.disabled = true;
    if(mode==='place' && placeCheckBtn) placeCheckBtn.disabled = true;
    if(mode==='guided' && guidedActionBtn) guidedActionBtn.disabled = true;
  }
  setHUD();
}
function resetGame(){
  round = 0; score = 0; clearInterval(timerId); timerId = null;
  $('#start').disabled = false; $('#check').disabled = true; $('#reset').disabled = true;
  orderArea.innerHTML=''; orderArea.classList.remove('slots');
  if(orderBank) orderBank.innerHTML='';
  placedBand && (placedBand.innerHTML=''); $$('#axis .tile').forEach(t=>t.remove());
  orderScreen.hidden = true; placeScreen.hidden = true; guidedScreen.hidden = true;
  guideFeedback && (guideFeedback.textContent='');
  setHUD();
}

/* ===== Wire it up ===== */
startBtn.addEventListener('click', startRound);
checkBtn.addEventListener('click', ()=>checkRound(false));
orderFinishBtn && orderFinishBtn.addEventListener('click', ()=>checkRound(false));
placeCheckBtn && placeCheckBtn.addEventListener('click', ()=>checkRound(false));
guidedActionBtn && guidedActionBtn.addEventListener('click', ()=>checkRound(false));
resetBtn.addEventListener('click', resetGame);
modeSel.addEventListener('change', setHUD);
eraSel.addEventListener('change', setHUD);
countSel.addEventListener('change', setHUD);
timerSel.addEventListener('change', setHUD);
orientationSel.addEventListener('change', ()=>{
  if(modeSel.value==='place') renderPlace();
  if(modeSel.value==='guided') updateGuidedAxis();
});
window.addEventListener('resize', ()=>{ if(modeSel.value==='place' && !placeScreen.hidden) layoutPlacedBand(); });
enterGameBtn.addEventListener('click', ()=>{
  learnScreen.hidden = true;
  gameScreen.hidden = false;
  controlsBar.style.display = '';
});
openSoloBtn && openSoloBtn.addEventListener('click', ()=>{
  const url = new URL(location.href);
  url.searchParams.set('solo','1');
  url.searchParams.set('noheader','1');
  window.open(url.toString(), '_blank');
});
// Quick mode buttons: jump straight to gameplay
function goToGameWithMode(m){
  if(modeSel) modeSel.value = m;
  learnScreen.hidden = true;
  gameScreen.hidden = false;
  controlsBar.style.display = '';
  startRound();
}
quickOrderBtn && quickOrderBtn.addEventListener('click', ()=>goToGameWithMode('order'));
quickPlaceBtn && quickPlaceBtn.addEventListener('click', ()=>goToGameWithMode('place'));
quickGuidedBtn && quickGuidedBtn.addEventListener('click', ()=>goToGameWithMode('guided'));
backIntroBtn && backIntroBtn.addEventListener('click', ()=>{
  // stop any timer and reset the game UI
  if(timerId){ clearInterval(timerId); timerId = null; }
  resetGame();
  // navigate back to intro
  gameScreen.hidden = true;
  learnScreen.hidden = false;
  controlsBar.style.display = 'none';
});
// Coach controls
(function(){
  const prev = document.getElementById('coachPrev');
  const next = document.getElementById('coachNext');
  const toggle = document.getElementById('coachToggle');
  const panel = document.getElementById('coachPanel');
  // How it works toggle
  const howToggle = document.getElementById('howToggle');
  const howPanel = document.getElementById('howPanel');
  // Wire buttons if present
  if(prev) prev.addEventListener('click', prevCoach);
  if(next) next.addEventListener('click', nextCoach);
  // Render slides and tabs now
  renderCoach();
  // Toggle panel visibility
  if(toggle && panel){
    const setLabel = ()=>{ toggle.textContent = panel.classList.contains('open') ? 'Hide help' : 'Want help understanding timelines?'; };
    setLabel();
    // ensure collapsed initial height
    panel.style.maxHeight = panel.classList.contains('open') ? (panel.scrollHeight + 'px') : '0px';
    toggle.addEventListener('click', ()=>{
      const willOpen = !panel.classList.contains('open');
      panel.classList.toggle('open');
      // animate height
      if(willOpen){ panel.style.maxHeight = panel.scrollHeight + 'px'; }
      else { panel.style.maxHeight = '0px'; }
      setLabel();
    });
  }
  // Toggle HOW panel visibility
  if(howToggle && howPanel){
    const setHowLabel = ()=>{ howToggle.textContent = howPanel.classList.contains('open') ? 'Hide how it works' : 'How it works'; };
    setHowLabel();
    howToggle.addEventListener('click', ()=>{ howPanel.classList.toggle('open'); setHowLabel(); });
  }
})();
// Solo mode activation via URL: ?solo=1 (and optional &noheader=1)
(function initSolo(){
  const params = new URLSearchParams(location.search);
  const hash = (location.hash||'').replace('#','');
  const wantSolo = params.has('solo') || params.get('screen')==='game' || hash==='play' || hash==='game';
  if (wantSolo) {
    document.body.classList.add('solo');
    learnScreen.hidden = true;
    gameScreen.hidden = false;
    controlsBar.style.display = '';
  }
  if (params.has('noheader')) {
    document.body.classList.add('noheader');
  }
})();
setHUD();
</script>
</body>
</html>
